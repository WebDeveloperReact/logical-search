# Searchgasm

## What is searchgasm?

Searchgasm is orgasmic. Maybe not orgasmic, but you will probably enjoy using it. Have you ever wanted to search the database in the same manner that you use your models? This plugin does exactly that. If you know how to use ActiveRecord you already know how to use this. The beauty in this plugin is that it brings the same power of ActiveRecord to searching. Take a resource for example. You let a hash of parameters be passed for creating and updating records. Why not do the same for searching? Check it out:

    def index
        @searcher = NameOfYourModelSearcher.new(params[:search_params])
        @records = @searcher.search
    end
    
Put that in your pipe and smoke it! Your resource now has a powerful search with 2 lines of code. The power is in the params now. The can pass a set of params that represent conditions and basically formulate their own search. No more writing manual SQL and no more writing lengthy code to perform a simple search. It's all right there and it works just like creating and updating records. So there is virtually no learning curve.

By no means is this meant to perform complex or large text based searches, it aims to bring simple searching to the same level as everything else in rails.



## Example

Let's assume the following model relationships: users => orders => line items

    @searcher = UserSearcher.new
    
    # Basic conditions
    @searcher.first_name_contains = "Ben"
    @searcher.last_name_is = "Johnson"
    @searcher.created_at_after = Time.now
    @searcher.age_greater_than = 18
    
    # Array conditions
    @searcher.email_contains = ["ben", "johnson"]       # combines the 2: email LIKE '%ben%' and email LIKE '%johnson%'.
                                                        # Arrays are applicable for any condition (see below for a detailed explanation)
    
    # Relationship conditions
    @searcher.orders.created_at_after = Time.now
    @searcher.orders.total_greater_than = 100
    @searcher.orders.line_items.total_less_than = 20
    
    # Options on how to return the data
    @searcher.per_page = 10             # set to 0 to return all, can also use "limit" instead
    @searcher.page = 2
    @searcher.order_by = "last_name"    # see below for "advanced" ordering
    @searcher.order_as = "ASC"
    
    # Search
    @searcher.search    # => returns users matching ALL of the conditions above
    @searcher.all       # => alias for search
    @searcher.count
    @searcher.first

Just to be clear, everything is escaped using ActiveRecord's built in functions. So SQL injection is not possible.



## Getting started

### 1. Install the plugin

    script/plugin install git://github.com/binarylogic/searchgasm.git


### 2. Set up your configuration (optional)

You can just put your searcher files in your models folder, but I like to put all of my searcher files in app/searchers and in my environment.rb I add the following configuration:
  
    # config/environment.rb
    
    config.load_paths += %W( #{RAILS_ROOT}/app/searchers )

Then setup your searcher configuration by adding a file in config/initializers called searchgasm.rb. The following is the default configuration, only add this file if you plan on changing this, or you want to enforce the defaults:

    # config/initializer/searchgasm.rb
    
    Searcher::Base.configure do |config|
        # the following values are the defaults
        config.per_page = 0             # can use "limit" instead
        config.order_as = "DESC"        # the order_by configuration depends on the model, it defaults to the primary key, order_by is best suited in your searcher file (see below)
        config.ignore_blanks = true
    end


### 3. Set up your searchers

Create a searcher for each model you want to search. For example if you want to search the User model you would create app/searchers/user_searcher.rb with the following content:
  
    # app/searchers/user_searcher.rb
    
    class UserSearcher < Searchgasm::Base
        # The following configuration values are the defaults. Therefore none of the below configurations are neccessary
        # They are only neccesssary if you want to override the defaults
        
        searching User      # this is not neccessary, automatically inferred by the name of the class
        per_page 0          # can use "limit" if you prefer
        order_by "id"
        order_as "DESC"
        ignore_blanks true
    end


### 4. Test it out

    # script/console
    
    UserSearcher.search(:first_name_contains => "Ben")

Play around with it. Check out the features below to perform different searches.



## Available conditions (by column type)

Each column in the respective model come preloaded with conditions that can easily be applied by calling a method in the following format: searcher_object.#{column_name}_#{condition}=

Here are the conditions available for each column type, they are pretty self explanatory:

### string, text
is, equals, is\_not, does\_not\_equal, begins\_with, starts\_with, contains, keywords, ends_with 

### datetime, timestamp, time, date
is, equals, is\_not, does\_not\_equal, greater\_than, gt, after, greater\_than\_or\_equal\_to, at\_least, gte, less\_than, lt, before, less\_than\_or\_equal\_to, lte, at_most

### integer, float, decimal
is, equals, is\_not, does\_not\_equal, greater\_than, gt, greater\_than\_or\_equal\_to, at\_least, gte, less\_than, lt, less\_than\_or\_equal\_to, lte, at_most



## Condition to SQL reference

*is, equals*                => column = ?
*is\_not, does\_not\_equal_*            => column != ?




## Features

### 1. Flexible ways to perform searches

Let's assume a user has many orders:

    UserSearcher.search(:first_name_contains => "Ben", :orders => {:total_greater_than => 0, :created_at_after => Time.now})
    
Or you can perform the same search this way:

    searcher = UserSearcher.new
    searcher.first_name_contains = "Ben"
    searcher.orders.total_greater_than = 0
    searcher.orders.created_at_after = Time.now
    searcher.search
    
All attributes and configurations can be called right upon instantiation, just like AcitveRecord:

    searcher = UserSearcher.new(:first_name_contains => "Ben", :orders => {:total_greater_than => 0, :created_at_after => Time.now})
    searcher.search



### 2. Advanced ordering

Ordering records works in the same manner and is just as powerful.

Let assume a user belongs to a user group, and a user group belongs to an account:

    searcher = UserSearcher.new
    searcher.order_by = :first_name                             # orders by the users first name
    searcher.order_by = {:user_group => :name}                  # orders by the user groups name
    searcher.order_by = {:user_group => {:account => :name}}    # orders by the user's user group account name

You can change the direction of the order by doing:

    searcher.order_as = "ASC" # or "DESC"


### 3. Searching through relationships

As I'm sure you saw in the example above you can traverse through all of your model relationships as you would with an ActiveRecord object:

Lets assume the following relationship: account => user groups => users => orders => line items

    searcher = AccountSearcher.new
    searcher.user_groups.users.orders.line_items.total_less_than = 100

Obviously this is something you want to try to avoid because the resulting query would be very intense, but you get the idea. Just like ActiveRecord, this can be an SQL train wreck if you are not careful, so I would advise thinking about the query you are going to execute while you set up your conditions.



### 4. Multiple values for a single condition
Doing this is just as simple as setting any other condition. There is a trick though: Based on the condition it automatically determines if you want to match ALL or ANY.

Just keep this rule in mind: Whenever possible narrow the search, without making it impossible.

For example:

    searcher = UserSearcher.new
    searcher.first_name_is = ["Ben", "David", "Bob"]

It is impossible for someone's first name to be all 3. So we assume you want users that have ANY of the first names. Another example:

    searcher = UserSearcher.new
    searcher.first_name_keywords = ["Ben", "David", "Bob"]
    
It is possible for a user to have a first name with all 3 of those words, not likely, but possible. So we assume you want users that have ALL of those words in their first name. This is useful for basic keywords searching.



### 5. Scoping
Let's assume: account => users. You are searching users and want to scope the search to users within a specific account. You can do this in a number of ways:

    @account.users.search(:first_name_contains => "ben")

Or this way:

    searcher = @account.users.build_search(:first_name_contains => "Ben")
    searcher.search
    
Or this way:

    searcher = UserSearcher.new
    searcher.scope = @account.users
    searcher.first_name_contains = "ben"
    searcher.search



### 6. Matching ANY of the conditions, not ALL
example coming soon



### 7. Saving a search for later
example coming soon



### 8. Roll your own special conditions using hooks
example coming soon



### 9. Creating "smart" relationships, such as itunes smart playlists
example coming soon



## Real world example

Note to self: show restful searching via index method with a data table that can be ordered and paginated.



## Features on the to do list

1. Extend ActiveResource, or allow searchers to use resources. Want to think this through a little more.



## Disclaimer

As selfish as it sounds, I made this plugin for my own personal needs. Obviously there is still some work to do, such as writing tests and better documentation. I am not an ActiveRecord expert, but I tried my best to mimic a lot of its features and the quality of it's code. So that running a search would feel like ActiveRecord. I am always open to suggestions, if you have any please send them my way. You can get ahold of me through my website [www.binarylogic.com](http://www.binarylogic.com).

This plugin was not created as an attempt to replace writing SQL. SQL is very powerful and you can't get any more flexible and powerful than pure SQL. This was created to help DRY up a lot of my code.

The bottom line is that this plugin has cleaned up my code quite a bit and made my life much easier, especially around the tedious / repetitive tasks such as creating search forms, data tables, and searchable resources. I hope it can do the same for you.

Copyright (c) 2007 Ben Johnson of [Binary Logic](http://www.binarylogic.com), released under the MIT license