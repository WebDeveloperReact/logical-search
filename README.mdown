# Searchgasm

Searchgasm is orgasmic. Maybe not orgasmic, but you will get aroused. So go grab a towel and let's dive in.

**Searchgasm's inspiration comes right from ActiveRecord. ActiveRecord lets you create objects that represent a record in the database, so why can't you create objects that represent searching the database? Now you can!**

The best part is that rails already has all kinds of nifty methods to make dealing with ActiveRecord objects quick and easy. For example, take the form\_for and fields\_for methods. You can do form\_for(@user) and get an entire form set up and ready to go. Then you can pass it a block and use your form builder. Simple and easy. Why not apply that same idea to a search object: form\_form(@search)? That's the idea behind this plugin. Searchgasm is searching, ordering, and pagination all rolled into one simple plugin.

I'm a big fan of understanding what I'm using, so here's a quick explanation: The design behind this plugin is pretty simple. The search object "santiizes" down into the options passed into ActiveRecord::Base.find(). It basically serves as a transparent filter between you and ActiveRecord::Base.find(). This filter provides "enhancements" that get translated into options that ActiveRecord::Base.find() can understand. It doesn't dig into the ActiveRecord internals, it only uses what is publicly available. It jumps in and helps out *only* when needed, otherwise it sits back and lets ActiveRecord do all of the work. Between that and the extensive tests this is a solid and fast plugin.

## What Searchgasm is all about

    # app/controllers/users_controller.rb
    def index
        @search = User.new_search(params[:search])
        @users, @users_count = @search.all, @search.count
    end

Now your view. Notice you can use your search object *just like* an ActiveRecord object. You also get some nifty helpers: page, per\_page, order\_by. All of these methods come with a list of options (see Searchgasm::Search::Helpers)

<code>
# app/views/users/index.html.erb
<%= form_for @search do |f| %>
    <% f.fields_for @search.conditions do |f| %>
        <%= f.text_field :first_name_contains %>
        <%= f.calendar_date_select :created_after %> # nice rails plugin for replacing date_select
        <% f.fields_for :orders, f.object.orders do |orders_f| %>
            <%= f.select :total_gt, (1..100) %>
        <% end %>
    <% end %>
    <%= f.submit %>
<% end %>

<table>
    <tr>
        <th><%= order_by :first_name %></th>
        <th><%= order_by :last_name %></th>
        <th><%= order_by :email %></th>
    </tr>
    <% @users.each do |user| %>
        <tr>
            <td><%= user.first_name %></td>
            <td><%= user.last_name %></td>
            <td><%= user.email %></td>
        </tr>
    <% end %>
</table>
</code>

Per page: <%= per_page %>
Page: <%= page %>

Obviously this is somewhat of an "old school" and inefficient way of doing things. You can do everything above via AJAX as well. Just prefix all of the helpers with "remote\_": remote\_per\_page, etc. Or set up the configuration (see below) to default to remote calls so you can use "per\_page".

## Install and use

    sudo gem install searchgasm

For rails > 2.1

    # environment.rb
    config.gem "searchgasm"

For rails < 2.1

    # environment.rb
    require "searchgasm"

Or as a plugin

    script/plugin install git://github.com/binarylogic/searchgasm.git

Now go into your console and try out any of these example with your own models.

**For all examples, let's assume the following relationships: User => Orders => Line Items**

## Simple Searching Example

    User.all(
        :conditions => {
            :first_name_contains => "Ben",          # first_name like '%Ben%'
            :email_ends_with => "binarylogic.com"   # email like '%binarylogic.com'
        },
        :per_page => 20     # limit 20
        :page => 3          # offset 60
    )

Instead of using the "all" method you could use any search method: first, find(:all), find(:first), count, sum, average, etc

## Detailed Example w/ object based searching (great for form\_for or fields\_for)

    # Instantiate
    @search = User.new_search(
        :conditions => {
            :first_name_contains => "Ben", 
            :age_gt => 18,
            :orders => {:total_lt => 100}
        },
        :per_page => 20,
        :page => 2,
        :order_by => {:orders => :total},
        :order_as => "DESC"
    )
    
    # Set conditions on relationships
    @search.conditions.email_ends_with = "binarylogic.com"
    @search.conditions.oders.line_items.created_after = Time.now
    
    # Set options
    @search.per_page = 50 # overrides the 20 set above
    
    # Set ANY of the ActiveRecord options
    @search.group = "last_name"
    @search.readonly = true
    # ... see ActiveRecord documentation
    
    # Return results just like ActiveRecord
    @search.all
    @search.search # alias for all
    @search.first

Take the @search object and pass it right into form\_for or fields\_for (see above).

## Calculations

Using the object from above:

    @search.average('id')
    @search.count
    @search.maximum('id')
    @search.minimum('id')
    @search.sum('id')
    @search.calculate(:sum, 'id') # any of the above calculations

Or do it from your model:

    User.count(:conditions => {:first_name_contains => "Ben"})
    User.sum('id', :conditions => {:first_name_contains => "Ben"})
    # ... all other calcualtions, etc.

## Different ways to search, take your pick

Any of the options used in the above example can be used in these, but for the sake of brevity I am only using a few:

    User.all(:conditions => {:age_gt => 18}, :per_page => 20)

    User.first(:conditions => {:age_gt => 18}, :per_page => 20)

    User.find(:all, :conditions => {::age_gt => 18}, :per_page => 20)

    User.find(:first, :conditions => {::age_gt => 18}, :per_page => 20)

    search = User.new_search(:conditions => {:age_gt => 18})    # build_search is an alias
    search.conditions.first_name_contains = "Ben"
    search.per_page = 20
    search.all

If you want to be hardcore:

    search = Searchgasm::Search.new(User, :conditions => {:age_gt => 18})
    search.conditions.first_name_contains = "Ben"
    search.per_page = 20
    search.all

## Search with conditions only

    conditions = User.new_conditions(:age_gt => 18)
    conditions.first_name_contains = "Ben"
    conditions.search
    conditions.all
    # ... all operations above are available

Pass a conditions object right into ActiveRecord:

    User.all(:conditions => conditions) # same as conditions.search

Again, if you want to be hardcore:

    conditions = Searchgasm::Conditions.new(User, :age_gt => 18)
    conditions.first_name_contains = "Ben"
    conditions.search

Now pass the conditions object right into form\_for or fields\_for (see above for example).

## Scoped searching

    @current_user.orders.find(:all, :conditions => {:total_lte => 500})
    @current_user.orders.count(:conditions => {:total_lte => 500})
    @current_user.orders.sum('total', :conditions => {:total_lte => 500})
    
    search = @current_user.orders.build_search('total', :conditions => {:total_lte => 500})

## Searching trees

For tree data structures you get a few nifty methods. Let's assume Users is a tree data structure.

    # Child of
    User.all(:conditions => {:child_of => User.roots.first})
    User.all(:conditions => {:child_of => User.roots.first.id})
    
    # Sibling of
    User.all(:conditions => {:sibling_of => User.roots.first})
    User.all(:conditions => {:sibling_of => User.roots.first.id})
    
    # Descendant of (includes all recursive children: children, grand children, great grand children, etc)
    User.all(:conditions => {:descendant_of => User.roots.first})
    User.all(:conditions => {:descendant_of => User.roots.first.id})
    
    # Inclusive descendant_of. Same as above but includes the root
    User.all(:conditions => {:inclusive_descendant_of => User.roots.first})
    User.all(:conditions => {:inclusive_descendant_of => User.roots.first.id})
    

## Available anywhere (relationships & named scopes)

Not only can you use searchgasm when searching, but you can use it when setting up relationships or named scopes:

    class User < ActiveRecord::Base
        has_many :expensive_pending_orders, :conditions => {:total_greater_than => 1_000_000, :state => :pending}, :per_page => 20
        named_scope :sexy, :conditions => {:first_name => "Ben", email_ends_with => "binarylogic.com"}, :per_page => 20
    end

## Always use protection...against SQL injections

If there is one thing we all know, it's to always use protection. That's why searchgasm protects you by default. The new\_search and new\_conditions methods are protected by default. This means that various checks are done to ensure it is not possible to perform any type of SQL injection. But this also limits how you can search, meaning you can't write raw SQL. If you want to be daring and search without protection prepare to accept the consequences. All that you have to do is add ! to the end of the methods: new\_search! and new\_conditions!.

### Protected from SQL injections

    search = Account.new_search(params[:search])
    conditions = Account.new_conditions(params[:conditions])

### *NOT* protected from SQL injections

    accounts = Account.find(params[:search])
    accounts = Account.all(params[:search])
    account = Account.first(params[:search])
    search = Account.new_search!(params[:search])
    conditions = Account.new_conditions!(params[:conditions])

Lesson learned: use new\_search and new\_conditions when passing in params as *ANY* of the options.

## Available Conditions

Depending on the type, each column comes preloaded with a bunch of nifty conditions:

    all columns
    => :equals, :does_not_equal

    :string, :text
    => :begins_with, :contains, :keywords, :ends_with

    :integer, :float, :decimal,:datetime, :timestamp, :time, :date
    => :greater_than, :greater_than_or_equal_to, :less_than, :less_than_or_equal_to

    tree data structures (see above "searching trees")
    => :child_of, :sibling_of, :descendant_of, :inclusive_descendant_of

Some of these conditions come with aliases, so you have your choice how to call the conditions. For example you can use "greater\_than" or "gt":

    :equals;                    => :is
    :does_not_equal             => :is_not, :not
    :begins_with                => :starts_with, :bw, :start
    :contains                   => :like, :has
    :ends_with                  => :ew, :ends, :end
    :greater_than               => :gt, :after
    :greater_than_or_equal_to   => :at_least, :gte
    :keywords                   => :kwords, :kw
    :less_than                  => :lt, :before
    :less_than_or_equal_to      => :at_most, :lte

### Enhanced searching and blacklisted words

You will notice above there is "contains" and "keywords". The difference is that "keywords" is an enhanced search. It acts like a real keyword search. It finds those keywords, in any order, and blacklists meaningless words such as "and", "the", etc. "contains" finds the EXACT string in the column you are searching, spaces and all.

### Roll your own conditions

I didn't include this function because its MySQL specific, and it's probably rarely used, but MySQL supports a "SOUNDS LIKE" function.

I want to use it, so let's add it:

    # config/initializers/searchgasm.rb
    # Actual function for MySQL databases only
    class SoundsLikeCondition < Searchgasm::Condition
      class << self
        # I pass you the column, you tell me what you want the method to be called.
        # If you don't want to add this condition for that column, return nil
        # It defaults to "#{column.name}_sounds_like". So if thats what you want you don't even need to do this.
        def name_for_column(column)
          super
        end
        
        # Only do this if you want aliases for your condition
        def aliases_for_column(column)
          ["#{column.name}_sounds", "#{column.name}_similar_to"]
        end
      end
      
      # You can return an array or a string. NOT a hash, because all of these conditions
      # need to eventually get merged together. The array or string can be anything you would put in
      # the :conditions option for ActiveRecord::Base.find()
      def to_conditions(value)
        ["#{quoted_table_name}.#{quoted_column_name} SOUNDS LIKE ?", value]
      end
    end
    
    Searchgasm::Condition.register_condition(SoundsLikeCondition)

Now test it out:

    search = User.new_search
    search.first_name_sounds_like = "Ben"
    search.all  # will return any user that has a first name that sounds like "Ben"

Pretty nifty, huh? You can create any condition ultimately creating any SQL you want. The sky is the limit.

## Credits

Author: [Ben Johnson](http://github.com/binarylogic) of [Binary Logic](http://www.binarylogic.com)

Credit to [Zack Ham](http://github.com/zackham) and [Robert Malko](http://github.com/malkomalko/) for helping with feature suggestions, cleaning up the readme / wiki, and cleaning up my code.


Copyright (c) 2008 [Ben Johnson](http://github.com/binarylogic) of [Binary Logic](http://www.binarylogic.com), released under the MIT license 